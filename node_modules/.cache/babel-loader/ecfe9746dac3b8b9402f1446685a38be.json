{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, function () {\n  'use strict'; // Matches the scheme of a URL, eg \"http://\"\n\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   * 6. Query, including \"?\", optional.\n   * 7. Hash, including \"#\", optional.\n   */\n\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may include \"/\", guaranteed.\n   * 3. Query, including \"?\", optional.\n   * 4. Hash, including \"#\", optional.\n   */\n\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n  var UrlType;\n\n  (function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n  })(UrlType || (UrlType = {}));\n\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n\n  function isRelative(input) {\n    return /^[.?#]/.test(input);\n  }\n\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n  }\n\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n  }\n\n  function makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      query,\n      hash,\n      type: UrlType.Absolute\n    };\n  }\n\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      url.type = UrlType.SchemeRelative;\n      return url;\n    }\n\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      url.type = UrlType.AbsolutePath;\n      return url;\n    }\n\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n    return url;\n  }\n\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  function mergePaths(url, base) {\n    normalizePath(base, base.type); // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    }\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n\n\n  function normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/'); // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n\n    let pointer = 1; // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n\n    let positive = 0; // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n\n    let addTrailingSlash = false;\n\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i]; // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      } // If we encounter a real directory, then we don't need to append anymore.\n\n\n      addTrailingSlash = false; // A current directory, which we can always drop.\n\n      if (piece === '.') continue; // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (rel) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n\n        continue;\n      } // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n\n\n      pieces[pointer++] = piece;\n      positive++;\n    }\n\n    let path = '';\n\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n\n\n  function resolve(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n\n    if (base && inputType !== UrlType.Absolute) {\n      const baseUrl = parseUrl(base);\n      const baseType = baseUrl.type;\n\n      switch (inputType) {\n        case UrlType.Empty:\n          url.hash = baseUrl.hash;\n        // fall through\n\n        case UrlType.Hash:\n          url.query = baseUrl.query;\n        // fall through\n\n        case UrlType.Query:\n        case UrlType.RelativePath:\n          mergePaths(url, baseUrl);\n        // fall through\n\n        case UrlType.AbsolutePath:\n          // The host, user, and port are joined, you can't copy one without the others.\n          url.user = baseUrl.user;\n          url.host = baseUrl.host;\n          url.port = baseUrl.port;\n        // fall through\n\n        case UrlType.SchemeRelative:\n          // The input doesn't have a schema at least, so we need to copy at least that over.\n          url.scheme = baseUrl.scheme;\n      }\n\n      if (baseType > inputType) inputType = baseType;\n    }\n\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n\n    switch (inputType) {\n      // This is impossible, because of the empty checks at the start of the function.\n      // case UrlType.Empty:\n      case UrlType.Hash:\n      case UrlType.Query:\n        return queryHash;\n\n      case UrlType.RelativePath:\n        {\n          // The first char is always a \"/\", and we need it to be relative.\n          const path = url.path.slice(1);\n          if (!path) return queryHash || '.';\n\n          if (isRelative(base || input) && !isRelative(path)) {\n            // If base started with a leading \".\", or there is no base and input started with a \".\",\n            // then we need to ensure that the relative path starts with a \".\". We don't know if\n            // relative starts with a \"..\", though, so check before prepending.\n            return './' + path + queryHash;\n          }\n\n          return path + queryHash;\n        }\n\n      case UrlType.AbsolutePath:\n        return url.path + queryHash;\n\n      default:\n        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n  }\n\n  return resolve;\n});","map":{"version":3,"mappings":"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","names":["schemeRegex","urlRegex","fileRegex","UrlType","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","type","Absolute","parseUrl","url","SchemeRelative","AbsolutePath","Query","Hash","RelativePath","Empty","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","resolve","inputType","baseUrl","baseType","queryHash"],"sources":["../src/resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nenum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}